/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
import { PolymerElement } from '@polymer/polymer/polymer-element.js';

import { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';
import './vaadin-contextmenu-event.js';
import './vaadin-device-detector.js';
import { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';
import './vaadin-context-menu-overlay.js';
import { html } from '@polymer/polymer/lib/utils/html-tag.js';
import { gestures, addListener, removeListener } from '@polymer/polymer/lib/utils/gestures.js';
/**
 * ```html
 * <vaadin-context-menu>
 *   <template>
 *     <vaadin-list-box>
 *       <vaadin-item>First menu item</vaadin-item>
 *       <vaadin-item>Second menu item</vaadin-item>
 *     </vaadin-list-box>
 *   </template>
 * </vaadin-context-menu>
 * ```
 *
 * ### “vaadin-contextmenu” Gesture Event
 *
 * `vaadin-contextmenu` is a gesture event (a custom event fired by Polymer),
 * which is dispatched after either `contextmenu` and long touch events.
 * This enables support for both mouse and touch environments in a uniform way.
 *
 * `<vaadin-context-menu>` opens the menu overlay on the `vaadin-contextmenu`
 * event by default.
 *
 * ### Menu Listener
 *
 * By default, the `<vaadin-context-menu>` element listens for the menu opening
 * event on itself. In order to have a context menu on your content, wrap
 * your content with the `<vaadin-context-menu>` element, and add a template
 * element with a menu. Example:
 *
 * ```html
 * <vaadin-context-menu>
 *   <template>
 *     <vaadin-list-box>
 *       <vaadin-item>First menu item</vaadin-item>
 *       <vaadin-item>Second menu item</vaadin-item>
 *     </vaadin-list-box>
 *   </template>
 *
 *   <p>This paragraph has the context menu provided in the above template.</p>
 *   <p>Another paragraph with the context menu.</p>
 * </vaadin-context-menu>
 * ```
 *
 * In case if you do not want to wrap the page content, you can listen for
 * events on an element outside the `<vaadin-context-menu>` by setting the
 * `listenOn` property:
 *
 * ```html
 * <vaadin-context-menu id="customListener">
 *   <template>
 *     <vaadin-list-box>
 *       ...
 *     </vaadin-list-box>
 *   </template>
 * </vaadin-context-menu>
 *
 * <div id="menuListener">The element that listens for the context menu.</div>
 *
 * &lt;script&gt;
 *   const contextMenu = document.querySelector('vaadin-context-menu#customListener');
 *   contextMenu.listenOn = document.querySelector('#menuListener');
 * &lt;/script&gt;
 * ```
 *
 * ### Filtering Menu Targets
 *
 * By default, the listener element and all its descendants open the context
 * menu. You can filter the menu targets to a smaller set of elements inside
 * the listener element by setting the `selector` property.
 *
 * In the following example, only the elements matching `.has-menu` will open the context menu:
 *
 * ```html
 * <vaadin-context-menu selector=".has-menu">
 *   <template>
 *     <vaadin-list-box>
 *       ...
 *     </vaadin-list-box>
 *   </template>
 *
 *   <p class="has-menu">This paragraph opens the context menu</p>
 *   <p>This paragraph does not open the context menu</p>
 * </vaadin-context-menu>
 * ```
 *
 * ### Menu Context
 *
 * You can bind to the following properties in the menu template:
 *
 * - `target` is the menu opening event target, which is the element that
 * the user has called the context menu for
 * - `detail` is the menu opening event detail
 *
 * In the following example, the menu item text is composed with the contents
 * of the element that opened the menu:
 *
 * ```html
 * <vaadin-context-menu selector="li">
 *   <template>
 *     <vaadin-list-box>
 *       <vaadin-item>The menu target: [[target.textContent]]</vaadin-item>
 *     </vaadin-list-box>
 *   </template>
 *
 *   <ul>
 *     <li>Foo</li>
 *     <li>Bar</li>
 *     <li>Baz</li>
 *   </ul>
 * </vaadin-context-menu>
 * ```
 *
 * ### Styling
 *
 * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
 *
 * @memberof Vaadin
 * @mixes Vaadin.ElementMixin
 * @mixes Polymer.GestureEventListeners
 * @demo demo/index.html
 */
class ContextMenuElement extends ElementMixin(GestureEventListeners(PolymerElement)) {
  static get template() {
    return html`
    <style>
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none !important;
      }
    </style>

    <slot id="slot"></slot>

    <vaadin-device-detector phone="{{_phone}}"></vaadin-device-detector>

    <vaadin-context-menu-overlay id="overlay" on-opened-changed="_onOverlayOpened" on-vaadin-overlay-open="_onVaadinOverlayOpen" with-backdrop="[[_phone]]" phone\$="[[_phone]]">
    </vaadin-context-menu-overlay>
`;
  }

  static get is() {
    return 'vaadin-context-menu';
  }

  static get version() {
    return '4.1.0-beta2';
  }

  static get properties() {
    return {

      /**
       * CSS selector that can be used to target any child element
       * of the context menu to listen for `openOn` events.
       */
      selector: {
        type: String
      },

      /**
       * True if the overlay is currently displayed.
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },

      /**
       * Event name to listen for opening the context menu.
       */
      openOn: {
        type: String,
        value: 'vaadin-contextmenu'
      },

      /**
       * The target element that's listened to for context menu opening events.
       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`
       * events.
       * @type {HTMLElement}
       * @default self
       */
      listenOn: {
        type: Object,
        value: function() {
          return this;
        }
      },

      /**
       * Event name to listen for closing the context menu.
       */
      closeOn: {
        type: String,
        value: 'click',
        observer: '_closeOnChanged'
      },

      _context: Object,

      _boundClose: Object,

      _boundOpen: Object,

      _templateClass: Object
    };
  }

  static get observers() {
    return [
      '_openedChanged(opened)',
      '_contextChanged(_context, _instance)',
      '_targetOrOpenOnChanged(listenOn, openOn)'
    ];
  }

  constructor() {
    super();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }

  // Runs before overlay is fully rendered
  _onOverlayOpened(e) {
    this._setOpened(e.detail.value);
  }

  // Runs after overlay is fully rendered
  _onVaadinOverlayOpen(e) {
    // Phone alignment is done in CSS
    if (!this._phone) {
      this.__alignOverlayPosition();
    }

    const child = this.$.overlay.content.querySelector(':not(style):not(slot)');
    if (child) {
      child.focus();
    }
  }

  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);

      this._oldListenOn.style.webkitTouchCallout = '';
      this._oldListenOn.style.webkitUserSelect = '';

      this._oldListenOn = null;
      this._oldOpenOn = null;
    }

    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);

      // note: these styles don't seem to work in Firefox on iOS.
      listenOn.style.webkitTouchCallout = 'none';
      listenOn.style.webkitUserSelect = 'none';

      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }

  _closeOnChanged(closeOn, oldCloseOn) {
    // Listen on this.$.overlay.root to workaround issue on
    //  ShadyDOM polyfill: https://github.com/webcomponents/shadydom/issues/159

    // Outside click event from overlay
    const evtOverlay = 'vaadin-overlay-outside-click';

    if (oldCloseOn) {
      this._unlisten(this.$.overlay, oldCloseOn, this._boundClose);
      this._unlisten(this.$.overlay.root, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(this.$.overlay, closeOn, this._boundClose);
      this._listen(this.$.overlay.root, closeOn, this._boundClose);
      this._unlisten(this.$.overlay, evtOverlay, this._preventDefault);
    } else {
      this._listen(this.$.overlay, evtOverlay, this._preventDefault);
    }
  }

  _preventDefault(e) {
    e.preventDefault();
  }

  _openedChanged(opened) {
    if (opened) {
      if (!this._instance) {
        this.$.overlay.template = this.querySelector('template');
        this._instance = this.$.overlay._instance;
      }
      document.documentElement.addEventListener('contextmenu', this._boundOnGlobalContextMenu, true);
    } else {
      document.documentElement.removeEventListener('contextmenu', this._boundOnGlobalContextMenu, true);
    }

    // Has to be set after instance has been created
    this.$.overlay.opened = opened;
  }

  _contextChanged(context, instance) {
    if (context === undefined || instance === undefined) {
      return;
    }
    instance.detail = context.detail;
    instance.target = context.target;
  }

  /**
   * Closes the overlay.
   */
  close() {
    this._setOpened(false);
  }

  _contextTarget(e) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);

      return Array.prototype.filter.call(targets, el => {
        return e.composedPath().indexOf(el) > -1;
      })[0];
    } else {
      return e.target;
    }
  }

  /**
   * Opens the overlay.
   * @param {Event} e used as the context for the menu. Overlay coordinates are taken from this event.
   */
  open(e) {
    if (e && !this.opened) {
      this._context = {
        detail: e.detail,
        target: this._contextTarget(e)
      };

      if (this._context.target) {
        this._preventDefault(e);
        e.stopPropagation();

        // Used in alignment which is delayed until overlay is rendered
        this.__x = this._getEventCoordinate(e, 'x');
        this.__y = this._getEventCoordinate(e, 'y');
        this._setOpened(true);
      }
    }
  }

  __alignOverlayPosition() {
    const overlay = this.$.overlay;
    const style = overlay.style;

    // Reset all properties before measuring
    ['top', 'right', 'bottom', 'left'].forEach(prop => style.removeProperty(prop));
    ['right-aligned', 'bottom-aligned'].forEach(attr => overlay.removeAttribute(attr));

    // Measure actual overlay and content sizes
    const overlayRect = overlay.getBoundingClientRect();
    const contentRect = overlay.$.overlay.getBoundingClientRect();

    // Maximum x and y values are imposed by content size and overlay limits.
    const xMax = overlayRect.right - contentRect.width;
    const yMax = overlayRect.bottom - contentRect.height;
    // Reuse saved x and y event values, in order to this method be used async
    // in the `vaadin-overlay-change` which guarantees that overlay is ready
    const x = this.__x || overlayRect.left;
    const y = this.__y || overlayRect.top;

    // Select one overlay corner and move to the event x/y position.
    // Then set styling attrs for flex-aligning the content appropriatelly.
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (x < wdthVport / 2 || x < xMax) {
      style.left = x + 'px';
    } else {
      style.right = Math.max(0, (wdthVport - x)) + 'px';
      overlay.setAttribute('right-aligned', '');
    }
    if (y < hghtVport / 2 || y < yMax) {
      style.top = y + 'px';
    } else {
      style.bottom = Math.max(0, (hghtVport - y)) + 'px';
      overlay.setAttribute('bottom-aligned', '');
    }
  }

  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        // Polymer gesture events, get coordinate from detail
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        // Unwrap detailed event
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      // Native mouse or touch event
      const prop = 'client' + coord.toUpperCase();
      return event.changedTouches ? event.changedTouches[0][prop] : event[prop];
    }
  }

  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }

  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }

  _onGlobalContextMenu(e) {
    if (!e.shiftKey) {
      e.preventDefault();
      this.close();
    }
  }
}

customElements.define(ContextMenuElement.is, ContextMenuElement);
export { ContextMenuElement };
